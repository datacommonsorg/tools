{"version":3,"sources":["back-end/utils.ts","back-end/graph.ts","back-end/parse-mcf.ts","back-end/parse-tmcf.ts","back-end/server-api.ts","utils.ts","TriplesTable.tsx","LoadingSpinner.tsx","DisplayNode.tsx","Header.tsx","ParsingErrorsTable.tsx","FileEntry.tsx","Home.tsx","App.tsx","index.tsx"],"names":["API_ROOT","ERROR_MESSAGES","getRemotePropertyLabels","dcid","outTargetUrl","inTargetUrl","Promise","all","fetch","then","response","json","data","properties","inPropertyLabels","outPropertyLabels","outLabels","inLabels","getRemotePropertyValues","label","isInverse","direction","targetUrl","res","values","getValueFromValueObj","valueObj","Error","value","Node","getNode","setDCID","existsInKG","doesExistsInKG","url","shouldReadLine","line","startsWith","length","id","localId","alreadyFetched","assertions","invAssertions","this","nodeHash","remote","mergeNode","absorbedNode","forEach","assert","src","push","invAssert","target","propLabels","valueList","val","isNode","source","Assertion","provenanceId","allLabels","createAssertionsFromLabels","dcidRef","localRef","includes","join","trim","existing","obj","property","provenance","Object","NAMESPACES","ParseMcf","fileName","prov","curNode","lineNum","errors","propValues","split","propValue","namespace","substring","indexOf","toString","replace","parsedValues","nodeRef","ns","firstValue","nodeId","localNodeHash","propLabel","parsedVal","parsePropValues","setCurNode","setCurNodeDCID","createAssertionsFromParsedValues","mcf","lines","parseLine","localNodes","keys","errMsgs","file","fileReader","FileReader","readAsText","rej","addEventListener","result","mcfParser","name","parseMcfStr","getColumnId","colIdMatch","match","getEntityID","localIdMatch","ParseTmcf","csvIndex","entityID","csvRow","filledValues","filledValue","colId","getLocalIdFromEntityId","colName","template","filledTemplate","fillPropertyValues","csvRows","mcfLines","row","fillTemplateFromRow","csvFile","require","csv","fromString","csvToMcf","tmcfFile","readTmcfFile","readCsvFile","fileList","clearFiles","finalReturn","pop","concat","fileExt","readFile","mcfOut","tmcfFileName","generateMcf","tmcfOut","retrieveNode","shouldCreateRemote","retrieved","getElemClass","setExistsInKG","colorLegend","goToId","homeHash","window","location","hash","goTo","openFile","fileUrl","open","TriplesTable","props","state","tableRows","loading","prevProps","triples","setState","getTripleRows","rows","API","elemClass","nodeTarget","title","utils","className","onClick","getRef","fileNames","provNames","tripleRows","index","missingVal","inverse","getTargetCell","getProvenanceCell","rowClassName","key","tableHeaders","Component","LoadingSpinner","msg","DisplayNode","ref","asserts","invAsserts","fetching","setNodeData","node","fetchRemoteData","Header","searchVal","event","keyCode","searchId","onHomeClick","type","list","placeholder","onChange","onKeyUp","handleSearch","subjIds","map","subjId","ParsingErrorsTable","errsList","errObj","FileEntry","mcfTmcfUrl","csvUrl","loadFiles","goToHome","toggle","required","multiple","accept","upload","Array","from","files","handleUrlKeyUp","Home","dropdown","addFileButtonClass","addFileButtonText","clear","toggleDropdown","errs","subjNodes","App","initialState","firstLoad","parsingErrs","fileHash","handleHashChange","parseUrl","params","URLSearchParams","get","fileUrls","getAll","loadRemoteFiles","fileUrlList","appendfileHash","newFiles","axios","request","method","responseType","prevState","submitFileList","onClearPress","uploadFiles","filesList","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ca1f202a.chunk.js","sourcesContent":["/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Module contains helper functions for api calls to data commons as well as\n * helper functions for parsing file to create local knowledge graph.\n */\n\nimport {Node} from './graph';\nconst API_ROOT = 'https://api.datacommons.org';\n\nconst ERROR_MESSAGES =\n    {\n      'curNode-length': 'error in declaring node',\n      'curNode-ns': 'invalid namespace in node declaration',\n      'setDCID-noCur': 'current node must be set before setting dcid',\n      'setDCID-multiple': 'a node can only have one dcid',\n      'setDCID-ref': 'dcid property must be a string, not a node reference',\n      'setDCID':\n          'cannot set dcid for current node; check if dcid is already set',\n      'assert-noCur': 'current node must be set before declaring properties',\n      'parse-noColon': 'missing \\':\\', incorrect mcf triple format',\n      'parse-noLabel': 'missing property label',\n      'multiple-tmcf': 'multiple TMCF files were uploaded, only the last one was used',\n    };\n\n/** A type to represent the format of the errors in the errList prop */\nexport interface ParsingError {\n  /** A list of errors generated when parsing a file */\n  errs: string[][];\n\n  /** The file that created the errors */\n  file: string;\n}\n\n/**\n * Gets all property labels of the given dcid that are in the DC KG.\n *\n * @param {string} dcid The dcid of the node to find property labels for.\n * @return {Object} An object containing both 'in' and 'out' property labels.\n */\nasync function getRemotePropertyLabels(dcid: string) {\n  // Get inward and outward property labels\n  const outTargetUrl = `${API_ROOT}/v1/properties/out/${dcid}`;\n  const inTargetUrl = `${API_ROOT}/v1/properties/in/${dcid}`;\n\n  const [inPropertyLabels, outPropertyLabels] = await Promise.all([\n    fetch(inTargetUrl)\n        .then((response) => response.json()\n            .then((data) => data.properties),\n        ),\n    fetch(outTargetUrl)\n        .then((response) => response.json()\n            .then((data) => data.properties),\n        ),\n  ]);\n\n  return {outLabels: outPropertyLabels, inLabels: inPropertyLabels};\n}\n\n/**\n * Gets all property values containing the given dcid, property label, and\n * direction.\n *\n * @param {string} dcid The dcid of the node to find property value for.\n * @param {string} label The property label to query for.\n * @param {boolean} isInverse Direction of property label, false indicates\n *     an outgoing label, true is an incoming label.\n * @return {Object} An object containing all found values matching the query.\n */\nasync function getRemotePropertyValues(\n    dcid: string, label: string, isInverse: boolean,\n) {\n  const direction = isInverse ? 'in' : 'out';\n  const targetUrl =\n      `${API_ROOT}/v1/property/values/${direction}/${dcid}/${label}`;\n\n  return fetch(targetUrl)\n      .then((res) => res.json())\n      .then((data) => data.values);\n}\n\nexport type DCPropertyValueResponse = {\n  /** the dcid being queried */\n  dcid?: string;\n\n  /** the value of the property being queried */\n  value?: string;\n\n  provenanceId: string;\n}\n\n/**\n * Parses an Object returned from the DC REST get_values API to create a Node\n * object from the value's dcid or to return the string value that the object\n * holds.\n *\n * @param {Object} valueObj An object returned from DC REST get_values API.\n * @return {Node | string} The created Node if the value object has a dcid,\n *     otherwise the string of the value.\n */\nfunction getValueFromValueObj(valueObj: DCPropertyValueResponse) {\n  if (!('dcid' in valueObj || 'value' in valueObj)) {\n    throw new Error(\n        'ERROR: DC API returned an object with no \"dcid\" or \"value\" field: ' +\n        valueObj);\n  }\n\n  if (valueObj.dcid) {\n    const value = Node.getNode('dcid:' + valueObj.dcid);\n    value.setDCID(valueObj.dcid);\n    value.existsInKG = true;\n    return value;\n  }\n  return valueObj.value;\n}\n\n/**\n * Queries Data Commons to determine if a given dcid is a part of any\n * triples in the Knowledge graph.\n * @param {string} dcid The dcid to check if exists in Data Commons\n * @return {Promise<boolean>} Returns true if given dcid is in any triples in\n *     Data Commons Knowledge Graph.\n */\nasync function doesExistsInKG(dcid: string) {\n  const url = `${API_ROOT}/v1/property/values/out/${dcid}/typeOf`;\n\n  // expected response if dcid exists is {\"values\":\"[...]}\n  // expected response if dcid does not exist is {}\n  return fetch(url)\n      .then((res) => res.json())\n      .then((data) => (data.values) ? true : false);\n}\n\n/**\n * Indicates if a line should be parsed.\n * @param {string} line The line to be checked.\n * @return {boolean} False if the line is a comment or empty, otherwise\n *     true.\n */\nfunction shouldReadLine(line: string) {\n  if (line.startsWith('//') || line.length === 0 || line.startsWith('#')) {\n    return false;\n  }\n  return true;\n}\n\nexport {\n  ERROR_MESSAGES, getRemotePropertyLabels,\n  getRemotePropertyValues,\n  getValueFromValueObj,\n  doesExistsInKG,\n  shouldReadLine,\n};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Module contains Node and Assertion classes which together create a local\n * version of the Data Commons Knowledge Graph.\n */\n\nimport {\n  DCPropertyValueResponse,\n  doesExistsInKG,\n  getRemotePropertyLabels,\n  getRemotePropertyValues,\n  getValueFromValueObj,\n} from './utils';\n\n/** Class representation of a single Node in the KG. */\nclass Node {\n  /**\n   * The local id used in a parsed mcf file.\n   * @type {string}\n   */\n  localId: string | null;\n\n  /**\n   * Whether triples from the remote Data Commons Knowledge Graph have already\n   * been fetched.\n   * @type {boolean}\n   */\n\n  alreadyFetched: boolean;\n\n  /**\n   * Whether the node exists in the Data Commons Knowledge Graph.\n   * @type {boolean}\n   */\n  existsInKG: boolean;\n\n  /**\n   * Dcid of the node. Set only if a remote id is referred to in a local file or\n   * pulled from the Data Commons Knowledge Graph.\n   * @type {string}\n   */\n\n  dcid: string | null;\n  /**\n   * Array of Assertion objects representing the outgoing triples of the Node\n   * object.\n   * @type {Array<Assertion>}\n   */\n  assertions: Assertion[];\n  /**\n   * Array of Assertion objects representing the incoming triples of the Node\n   * object.\n   * @type {Array<Assertion>}\n   */\n  invAssertions: Assertion[];\n\n  static nodeHash: any;\n\n  /**\n   * Create a Node based on a given id.\n   * @param {string} id The id of the node to create, including the namespace.\n   */\n  constructor(id: string) {\n    this.localId = id.startsWith('l:') ? id : null;\n    this.dcid = null;\n\n    this.alreadyFetched = false;\n    this.existsInKG = false;\n\n    this.assertions = [];\n    this.invAssertions = [];\n\n    Node.nodeHash[id] = this;\n  }\n\n  /**\n   * Returns a node with the given ID. All callers of this function expect a\n   * Node object to be returned.If the node does not exist already, then it\n   * should be created. If the created node with the requested id does not exist\n   * in the local file or in the Data Commons Knowledge Graph, then the\n   * front-end will demonstrate this to the user.\n   *\n   * @param {string} id The id of the node to find, including the namespace.\n   * @return {Node} The found node if it exists or is created.\n   */\n  static getNode(id: string) {\n    const existing = Node.nodeHash[id];\n    return existing ? existing : new Node(id);\n  }\n\n  /**\n   * Indicates if a given object is an instance of Node class.\n   * @param {Object} obj The object to check.\n   * @return {boolean} True if the object is an instance of Node.\n   */\n  static isNode(obj: Object) {\n    return obj instanceof Node;\n  }\n\n  /**\n   * Sets the dcid of Node object. Checks if a separate node based on the dcid\n   * already exists. If remote node exists, then the remote node is absorbed by\n   * current node via mergeNode() method.\n   *\n   * @param {string} dcid The dcid to be added to the Node object, should not\n   *     include the dcid namespace.\n   * @return {boolean} False if the node already has a different dcid, true\n   *     otherwise.\n   */\n  setDCID(dcid: string) {\n    if (this.dcid && this.dcid !== dcid) {\n      return false;\n    }\n\n    const remote = Node.nodeHash['dcid:' + dcid];\n    if (remote && remote !== this) {\n      this.mergeNode(remote);\n    }\n    this.dcid = dcid;\n    Node.nodeHash['dcid:' + dcid] = this;\n    return true;\n  }\n\n  /**\n   * Moves the assertions and inverse Assertions from the given param node to\n   * the calling Node object by changing the src property for assertions and the\n   * target property of the invAssertions.\n   *\n   * @param {Node} absorbedNode The node object whose triples should be copied.\n   */\n  mergeNode(absorbedNode: Node) {\n    if (this.localId === absorbedNode.localId) {\n      return;\n    }\n\n    absorbedNode.assertions.forEach((assert) => {\n      assert.src = this;\n      this.assertions.push(assert);\n    });\n\n    absorbedNode.invAssertions.forEach((invAssert) => {\n      invAssert.target = this;\n      this.invAssertions.push(invAssert);\n    });\n  }\n\n  /**\n   * Sets the property existsInKG to true if the Node has triples in the DC KG.\n   */\n  async setExistsInKG() {\n    if (!this.dcid || this.existsInKG) {\n      return;\n    }\n    this.existsInKG = await doesExistsInKG(this.dcid);\n  }\n\n  /**\n   * Creates Assertion objects from a list of property labels by calling the\n   * helper function getRemotePropertyValues from utils.js to find the values\n   * in Data Commons given the current node, a property label, and the direction\n   * of the label.\n   *\n   * @param {Array<string>} propLabels List of property labels associated with\n   *     the calling Node object in Data Commons.\n   * @param {boolean} isInverse True if the list of labels are incoming labels,\n   *     meaning the calling Node object is the target of the triple. False if\n   *     the calling Node is the source of the triple.\n   */\n  async createAssertionsFromLabels(propLabels: string[], isInverse: boolean) {\n    if (!propLabels || propLabels.length === 0 || !this.dcid) {\n      return;\n    }\n\n    for (const label of propLabels) {\n      await getRemotePropertyValues(this.dcid, label, isInverse)\n          .then((valueList) => {\n            if (!valueList) {\n              throw new Error('No property values for dcid: ' + this.dcid +\n                              ' label: ' + label);\n            }\n\n            valueList.forEach((valueObj: DCPropertyValueResponse) => {\n              const val = getValueFromValueObj(valueObj);\n\n              if (isInverse && !Node.isNode(val)) {\n                throw new Error(\n                    'Error creating assertion with non Node source');\n              }\n\n              const source = isInverse ? val : this;\n              const target = isInverse ? this : val;\n\n              // if val is a node and has already been fetched, then the\n              // assertion would already be stored in both nodes\n              if (!Node.isNode(val) || !val.alreadyFetched) {\n                new Assertion(source, label, target, valueObj.provenanceId);\n              }\n            });\n          });\n    }\n  }\n\n  /**\n   * Stores remote triples as assertions and inverse Assertions of the calling\n   * Node object. Sets the alreadyFetched property to true if data is fetched.\n   */\n  async fetchRemoteData() {\n    if (this.alreadyFetched || !this.dcid) {\n      return;\n    }\n\n    await getRemotePropertyLabels(this.dcid).then(async (allLabels) => {\n      await this.createAssertionsFromLabels(allLabels.outLabels,\n          /* isInverse */ false);\n      await this.createAssertionsFromLabels(allLabels.inLabels,\n          /* isInverse */ true);\n    });\n    this.alreadyFetched = true;\n  }\n\n  /**\n   * Returns the reference to the node that is displayed in browser. If the\n   * node has a dcid, then the dcid will be displayed. If the node's local id\n   * is different, then the local id is also displayed.\n   * Ex: <dcid> [l:<localId>]\n   * @return {string} The reference to the node to be displayed.\n   */\n  getRef() {\n    const dcidRef = this.dcid ? this.dcid : '';\n    let localRef = '';\n\n    if (this.localId && !this.localId.includes('dcid')) {\n      localRef = '[' + this.localId + ']';\n    }\n    return [dcidRef, localRef].join(' ').trim();\n  }\n}\n\nNode.nodeHash = {}; // stores all created nodes\n\n/** Class representation of a single Assertion or triple in the KG. */\nclass Assertion {\n  /**\n   * The source or subject of the triple.\n   * @type {Node}\n   */\n  src: Node;\n  /**\n   * The property label or predicate of the triple.\n   * @type {string}\n   */\n  property: string;\n  /**\n   * The provenance of the triple.\n   * @type {string}\n   */\n  provenance: string;\n  /**\n   * The target or object of the triple.\n   * @type {string|Node}\n   */\n  target: string | Node;\n\n  /**\n   * Create a triple, setting the source's assertion prop to be the new object.\n   *\n   * @param {Node} src The source or subject of the triple.\n   * @param {string} property The property label of the triple.\n   * @param {Node|string} target The predicate or target of the triple.\n   * @param {string} provenance The provenance of the triple.\n   */\n  constructor(\n      src: Node, property: string, target: Node | string, provenance: string,\n  ) {\n    this.src = src;\n    this.property = property;\n    this.provenance = provenance;\n    this.target = target;\n\n    src.assertions.push(this);\n\n    if (target instanceof Object) {\n      target.invAssertions.push(this);\n    }\n  }\n}\n\nexport {Node, Assertion};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Parses an mcf file and creates local knowledge graph of the parsed data\n * using Node and Assertion Class objects.\n */\n\nimport {Assertion, Node} from './graph';\nimport {ERROR_MESSAGES, shouldReadLine} from './utils';\n\nconst NAMESPACES = {\n  'l': 'l',\n  'schema': 'dcid',\n  'dcs': 'dcid',\n  'dcid': 'dcid',\n};\n\ntype ParsedValue = {\n  ns: 'l' | 'schema' | 'dcs' | 'dcid',\n  ref: string\n};\n\ntype ParseFileResponse = {\n  /** A list of errors that occurred while parsing\n   * the files\n   */\n  errMsgs: string[][];\n\n  /** A list of the ids of the subject nodes */\n  localNodes: string[];\n}\n\n/** Class responsible for parsing an mcf file. */\nclass ParseMcf {\n  /**\n   * Provenance to be used for any Assertion objects created during parsing,\n   * based off of the mcf file name.\n   * @type {string}\n   */\n  prov: string;\n  /**\n   * Current subject Node for any Assertion created. Set when a 'Node:' property\n   * label is parsed.\n   * @type {Node}\n   */\n  curNode: Node | null;\n  /**\n   * Current line number of the line being parsed, used for identifying location\n   * of syntax error in the mcf file.\n   * @type {number}\n   */\n\n  lineNum: number;\n\n  /**\n   * List of error messages regarding mcf syntax that are to be displayed to\n   * the user. A single entry of this array should be in the format of:\n   * [line number, line, error message]\n   * @type {Array<Array<String>>}\n   */\n  errors: string[][];\n\n  /** Current line being parsed */\n  line: string | null;\n\n  static localNodeHash: any;\n\n  /**\n   * Create a ParseMcf object which keeps tracks of the current source node of\n   * each triple in the mcf and the provenance, which is the mcf file name.\n   * @param {string} fileName Name of the file to be parsed.\n   */\n  constructor(fileName: string) {\n    this.prov = fileName;\n    this.curNode = null;\n    this.lineNum = -1;\n    this.errors = [];\n    this.line = null;\n  }\n\n  /**\n   * Parses a string representing a comma separated list of property values\n   * from a line of an mcf file. Returns a list having either a string or\n   * <namespace, reference> pair.\n   *\n   * @param {string} propValues A comma separated list of property values.\n   * @return {Array<(string|Object)>} Array of\n   *     parsed values.\n   */\n  parsePropValues(propValues: string) {\n    const values = [];\n    // split propValues on commas which are not enclosed by double quotes\n    // split string at each comma followed by even number of double quotes\n    // caveat: does not work if quotes are unbalanced\n    for (const propValue of propValues.split(/,(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/)) {\n      const namespace = propValue.split(':')[0].trim();\n      if (namespace in NAMESPACES) {\n        values.push({\n          'ns': namespace,\n          'ref': propValue.substring(propValue.indexOf(':') + 1).trim(),\n        });\n      } else if (propValue.split(':').length > 1 &&\n                 !namespace.startsWith('\"')) {\n        this.errors.push([this.lineNum.toString(), this.line as string, 'unrecognized namespace']);\n        return [];\n      } else {\n        // push property value with surrounding double quotes trimmed\n        values.push(propValue.replace(/^[\" ]*(.*?)[\" ]*$/g, '$1'));\n      }\n    }\n    return values;\n  }\n\n  /**\n   * Sets curNode variable of the calling ParseMcf object based on the passed in\n   * parsed values of a line of mcf, given the property label for the line was\n   * 'Node'. The parsed value either is a local reference with or without the\n   * 'l' namespace, or it has a remote namespace. If the namespace is remote,\n   * then the dcid for curNode is set. Updates localNodeHash mapping to store\n   * the subject nodes to be displayed in home screen of browser.\n   *\n   * @param {Array<string|Object>} parsedValues The array of parsed values from\n   *     a line of mcf with property label of 'Node'.\n   */\n  setCurNode(parsedValues: Object[]) {\n    if (parsedValues.length !== 1) {\n      this.errors.push(\n          [this.lineNum.toString(), this.line as string, ERROR_MESSAGES['curNode-length']]);\n      return;\n    }\n\n    let nodeRef;\n    let ns;\n\n    if (parsedValues[0] instanceof Object) {\n      // handle case: Node: dcid:remoteRef, which means that\n      // parsedValues[0] === {'ns':'dcid', 'ref':'remoteRef' }\n      const firstValue = (parsedValues[0]) as ParsedValue;\n      ns = firstValue['ns'];\n      if (ns === 'dcid') {\n        ns = ns + ':';\n        nodeRef = firstValue['ref'];\n      } else {\n        this.errors.push(\n            [this.lineNum.toString(), this.line as string, ERROR_MESSAGES['curNode-ns']]);\n        return;\n      }\n    } else {\n      // handle case: Node: localRef, which means parsedValues[0]==='localRef'\n      nodeRef = parsedValues[0];\n      ns = '';\n    }\n    // combine the namespace and reference into single id\n    const nodeId = 'l:' + ns + nodeRef;\n    this.curNode = Node.getNode(nodeId);\n\n    if (ns === 'dcid:') {\n      if (this.curNode && !this.curNode.setDCID(nodeRef)) {\n        this.errors.push([this.lineNum.toString(), this.line as string, ERROR_MESSAGES['setDCID']]);\n        return;\n      }\n      ParseMcf.localNodeHash[ns + nodeRef] = this.curNode;\n    } else {\n      ParseMcf.localNodeHash[nodeId] = this.curNode;\n    }\n  }\n\n  /**\n   * Sets the dcid of the curNode variable of the calling ParseMcf object given\n   * the property label of the line being parsed is 'dcid'.\n   * @param {Array<string|Object>} parsedValues The array of parsed values from\n   *     a line of mcf with property label of 'dcid'.\n   */\n  setCurNodeDCID(parsedValues: (string | Object)[]) {\n    if (!this.curNode) {\n      this.errors.push(\n          [this.lineNum.toString(), this.line as string, ERROR_MESSAGES['setDCID-noCur']]);\n      return;\n    }\n    if (parsedValues.length !== 1) {\n      this.errors.push(\n          [this.lineNum.toString(), this.line as string, ERROR_MESSAGES['setDCID-multiple']]);\n      return;\n    }\n    if (typeof parsedValues[0] !== 'string') {\n      this.errors.push(\n          [this.lineNum.toString(), this.line as string, ERROR_MESSAGES['setDCID-ref']]);\n      return;\n    }\n\n    if (!this.curNode.setDCID(parsedValues[0])) {\n      this.errors.push([this.lineNum.toString(), this.line as string, ERROR_MESSAGES['setDCID']]);\n    }\n  }\n\n  /**\n   * Create Assertion objects using curNode variable of calling ParseMcf object\n   * as the source of the triple and the prov variable of the ParseMcf object\n   * as the provenance of the triple.One Assertion object is created for each\n   * parsed value given in the array parsedValues.\n   *\n   * @param {string} propLabel The property label of the triple to be created.\n   * @param {Array<string|Object>} parsedValues The parsed values from a line of\n   *     mcf, used to create the target for each created triple.\n   */\n  createAssertionsFromParsedValues(propLabel: string, parsedValues: (string | Object)[]) {\n    if (!this.curNode) {\n      this.errors.push(\n          [this.lineNum.toString(), this.line as string, ERROR_MESSAGES['assert-noCur']]);\n      return;\n    }\n    for (const val of parsedValues) {\n      let target;\n      if (val instanceof Object) {\n        const parsedVal = val as ParsedValue;\n        target = Node.getNode(NAMESPACES[parsedVal['ns']] + ':' + parsedVal['ref']);\n        if (NAMESPACES[parsedVal['ns']] === 'dcid') {\n          if (!target.setDCID(parsedVal['ref'])) {\n            this.errors.push(\n                [this.lineNum.toString(), this.line as string, ERROR_MESSAGES['setDCID']]);\n          }\n        }\n      } else {\n        target = val;\n      }\n      new Assertion(this.curNode, propLabel, target, this.prov);\n    }\n  }\n\n  /**\n   * Parses a single line of an mcf file. First determines if the line should be\n   * read, then finds the property label, then the property values and creates\n   * an Assertion object based on the triple, given the calling object has a\n   * curNode property that acts as the source  and a prov property that gives\n   * the provenance for the triple.\n   *\n   * @param {string} line The line of mcf to be parsed.\n   */\n  parseLine(line: string) {\n    line = line.trim();\n\n    if (!shouldReadLine(line)) {\n      return; // not an error\n    }\n\n    if (!line.includes(':')) {\n      this.errors.push(\n          [this.lineNum.toString(), this.line as string, ERROR_MESSAGES['parse-noColon']]);\n      return;\n    }\n\n    const propLabel = line.split(':', 1)[0].trim();\n    const propValues = line.substring(line.indexOf(':') + 1).trim();\n\n    if (!propLabel) {\n      this.errors.push(\n          [this.lineNum.toString(), this.line as string, ERROR_MESSAGES['parse-noLabel']]);\n      return;\n    }\n    if (!propValues) {\n      // if there is a missing property value, do not return error\n      return;\n    }\n\n    const parsedValues = this.parsePropValues(propValues);\n\n    switch (propLabel) {\n      case 'Node':\n        this.setCurNode(parsedValues);\n        break;\n\n      case 'dcid':\n        this.setCurNodeDCID(parsedValues);\n        break;\n\n      default:\n        this.createAssertionsFromParsedValues(propLabel, parsedValues);\n    }\n  }\n\n  /**\n   * Parses each line of the given string of an mcf file after setting the prov\n   * property of the calling ParseMcf object.\n   * @param {string} mcf The string representation of an mcf file to parse.\n   * @return {Object} A list of the local node ids and the list of error\n   * messages which should be empty if no mcf syntax errors were found.\n   */\n  parseMcfStr(mcf: string) {\n    const lines = mcf.split('\\n');\n    this.lineNum = 1;\n\n    lines.forEach((line) => {\n      this.line = line;\n      this.parseLine(line);\n      this.lineNum++;\n    });\n\n    return {\n      localNodes: Object.keys(ParseMcf.localNodeHash),\n      errMsgs: this.errors,\n    };\n  }\n\n  /**\n   * Reads an mcf file into a string, then creates ParseMcf object to parse the\n   * string.\n   * @param {FileObject} file An mcf file from the html file-input element.\n   * @return {Promise} Promise returns the result of parseMcfStr.\n   */\n  static readFile(file: Blob): Promise<ParseFileResponse> {\n    const fileReader = new FileReader();\n    fileReader.readAsText(file);\n\n    return new Promise((res, rej) => {\n      fileReader.addEventListener('loadend', (result) => {\n        const mcfParser = new ParseMcf((file as File).name);\n        res(mcfParser.parseMcfStr(fileReader.result as string));\n      });\n      fileReader.addEventListener('error', rej);\n    });\n  }\n}\n\nParseMcf.localNodeHash = {}; // stores mapping of mcf subject IDs to the Node\n\nexport {ParseMcf};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {shouldReadLine} from './utils';\n\n/**\n * Returns the string following '->' in  a given string. Used for getting csv\n * column name when filling in tmcf with values from csv.\n * Ex:   C:SomeDataset->GeoId would return 'GeoId'\n * @param {string} propValue The string to look for a column name in.\n * @return {string|null} The column name that comes after '->'.\n */\nfunction getColumnId(propValue: string) {\n  const colIdMatch = propValue.match('C:(.*)->(.*)');\n  if (colIdMatch) {\n    return colIdMatch[0];\n  }\n  return null;\n}\n\n/**\n * Returns a string matching the format E:'DataSet Name'->'Entity #'.\n * @param {string} line The string to look for a match in.\n * @return {string|null} The entity id that matches the specified format.\n */\nfunction getEntityID(line: string) {\n  const localIdMatch = line.match('E:(.*)->(.*)');\n  if (localIdMatch) {\n    return localIdMatch[0];\n  }\n  return null;\n}\n\n/**\n * Class responsible for converting one TMCF file and one CSV file into an MCF\n * string.\n */\nclass ParseTmcf {\n  /**\n   * Current row number of the csv file that is being parsed.\n   * @type {number}\n   */\n  csvIndex;\n\n  /**\n  * Create a ParseTmcf object which keeps tracks of the current csv row\n  * number being parsed.\n  */\n  constructor() {\n    this.csvIndex = -1;\n  }\n\n  /**\n   * Generates a local id for a node of specfic row in csv from an entity id\n   * used in tmcf file. Ex: E:SomeDataset->E1 => SomeDataset_E1_R<index>\n   * @param {string} entityID The entity id used in tmcf file.\n   * @return {string|null} The local id for the node of the specific csv row.\n   */\n  getLocalIdFromEntityId(entityID: string) {\n    if (entityID) {\n      return entityID.replace('->', '_').replace('E:', '') + '_R' +\n             this.csvIndex;\n    }\n    return null;\n  }\n\n  /**\n   * Converts propertyValues from a line of tmcf to mcf by either converting\n   * entity ids to local ids or replacing a csv column reference with the actual\n   * value from the csv.\n   *\n   * @param {string} propValues The property values from the line of TMCF.\n   * @param {Object} csvRow The JSON representation of a single row of a csv\n   *     file. The keys are the column names and values are the corresponding\n   *     entries of the csv for the specfic row/column.\n   * @return {string} The mcf version of the given propValues which has local\n   *     ids in lieu of entity ids and csv column references replaces with csv\n   *     values.\n   */\n  fillPropertyValues(propValues: string, csvRow: Object) {\n    const filledValues = [];\n\n    for (const propValue of propValues.split(',')) {\n      let filledValue;\n\n      const entityID = getEntityID(propValue);\n      const colId = getColumnId(propValue);\n\n      if (entityID) {\n        // convert entity id format to local id format\n        // Ex: E:SomeDataset->E1 => l:SomeDataset_E1_R<index>\n        const localId = 'l:' + this.getLocalIdFromEntityId(entityID);\n        filledValue = propValue.replace(entityID, localId);\n      } else if (colId) {\n        // Replace csv column placeholder with the value\n        const colName = colId.split('->')[1];\n        filledValue = propValue.replace(colId, (csvRow as any)[colName]);\n      } else {\n        filledValue = propValue;\n      }\n      filledValues.push(filledValue);\n    }\n    return filledValues.join(',');\n  }\n\n  /**\n   * Convert a single row from the csv file to multiple lines of mcf by filling\n   * in the appropriate values in the tmcf template.\n   * @param {string} template The string representation of tmcf file.\n   * @param {Object} csvRow The JSON representation of a single row of a csv\n   *     file. The keys are the column names and values are the corresponding\n   *     entries of the csv for the specfic row/column.\n   * @return {string} The constructed mcf for the single row from csv file.\n   */\n  fillTemplateFromRow(template: string, csvRow: Object) {\n    const filledTemplate = [];\n\n    for (const line of template.split('\\n')) {\n      if (!line.trim() || !shouldReadLine(line)) {\n        filledTemplate.push('');\n        continue;\n      }\n\n      const propLabel = line.split(':')[0].trim();\n      const propValues = line.substring(line.indexOf(':') + 1).trim();\n\n      if (propLabel === 'Node') {\n        if (propValues.includes(',')) {\n          throw new Error('cannot have multiple ids for Node declaration');\n        }\n        const entityID = getEntityID(propValues);\n        if (entityID) {\n          filledTemplate.push(propLabel + ': ' +\n                              this.getLocalIdFromEntityId(entityID));\n        } else {\n          filledTemplate.push(propLabel + ': ' + propValues);\n        }\n      } else {\n        const filledValues = this.fillPropertyValues(propValues, csvRow);\n        filledTemplate.push(propLabel + ': ' + filledValues);\n      }\n    }\n    return filledTemplate.join('\\n');\n  }\n\n  /**\n   * Creates an mcf string from a string representation of TMCF file and the\n   * json representation of a CSV file. The whole template from the tmcf is\n   * populated with values for each row of the csv.\n   * @param {string} template The string representation of a tmcf file.\n   * @param {Array<Object>} csvRows The json representation of the csv file.\n   *     Each Object element of the array represents one row of the csv.\n   * @return {string} The generated mcf as a string.\n   */\n  csvToMcf(template: string, csvRows: Object[]) {\n    this.csvIndex = 1;\n    const mcfLines = [];\n    for (const row of csvRows) {\n      mcfLines.push(this.fillTemplateFromRow(template, row));\n      this.csvIndex += 1;\n    }\n    return mcfLines.join('\\n');\n  }\n\n  /**\n   * Converts CSV file to an array of JS Object where each JS Object in the\n   * array represents one row of the csv. The keys of the object are the column\n   * header names and the values of the object are the csv entries in that\n   * column of the given row the object represents.\n   * @param {string} template The string representation of a tmcf file.\n   * @param {FileObject} csvFile The csv file from html file-input element.\n   * @return {Array<Object>} The json representation of the csv file.\n   */\n  async readCsvFile(template: string, csvFile: Blob) {\n    const fileReader = new FileReader();\n    fileReader.readAsText(csvFile);\n    return new Promise((res, rej) => {\n      fileReader.addEventListener('loadend', (result) => {\n        const csv = require('csvtojson');\n        csv()\n            .fromString(fileReader.result)\n            .then((csvRows: Object[]) => {\n              res(this.csvToMcf(template, csvRows));\n            });\n      });\n      fileReader.addEventListener('error', rej);\n    });\n  }\n\n  /**\n   * Reads a tmcf file and returns the contents as a string\n   * @param {FileObject} tmcfFile The tmcf file from html file-input element.\n   * @return {string} The string representation of the tmcf file.\n   */\n  static async readTmcfFile(tmcfFile: Blob): Promise<string | ArrayBuffer | null> {\n    const fileReader = new FileReader();\n    fileReader.readAsText(tmcfFile);\n    return new Promise((res, rej) => {\n      fileReader.addEventListener('loadend',\n          (result) => {\n            res(fileReader.result);\n          });\n      fileReader.addEventListener('error', rej);\n    });\n  }\n\n  /**\n   * Converts a TMCF file and CSV file to an MCF string.\n   * @param {FileObject} tmcfFile The tmcf file from html file-input element.\n   * @param {FileObject} csvFile THe csv file from html file-input element.\n   * @return {string} The translated mcf as a string.\n   */\n  static async generateMcf(tmcfFile: Blob, csvFile: Blob) {\n    return ParseTmcf.readTmcfFile(tmcfFile).then((template: string | ArrayBuffer | null) => {\n      const tmcfParser = new ParseTmcf();\n      return tmcfParser.readCsvFile(template as string, csvFile);\n    });\n  }\n}\n\nexport {ParseTmcf};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* Functions to relay information from the back-end to the front-end. */\n\nimport {Node} from './graph';\nimport {ParseMcf} from './parse-mcf';\nimport {ParseTmcf} from './parse-tmcf';\nimport {ParsingError, ERROR_MESSAGES} from './utils';\n\ntype ParseFileResponse = {\n  /** A list of errors that occurred while parsing\n   * the files\n   */\n  errMsgs: ParsingError[];\n\n  /** A list of the ids of the subject nodes */\n  localNodes: string[];\n}\n/**\n * Parses App state's files list.\n * @param {Array<Blob>} fileList The list of blobs to be parsed.\n * @return {Object} An object containing the ids of the subject nodes and any\n *     parsing error message objects.\n */\nasync function readFileList(fileList: Blob[]) {\n  // Clear previously stored files\n  clearFiles();\n\n  const finalReturn: ParseFileResponse = {'errMsgs': [], 'localNodes': []};\n\n  // Find TMCF file, if it exists\n  let tmcfFile = null;\n  for (const file of fileList) {\n    const fileName = (file as File).name;\n    const fileExt = fileName.split('.').pop();\n\n    if(fileExt === \"tmcf\"){\n      if (tmcfFile) {\n        // If another TMCF file was found, throw an error\n        finalReturn['errMsgs'] = finalReturn['errMsgs'].concat([{\n          'file': fileName,\n          'errs': [\n            [\"-1\", \"\", ERROR_MESSAGES['multiple-tmcf']]\n          ]\n        }]);\n      }\n\n      tmcfFile = file;\n    }\n  }\n\n  for (const file of fileList) {\n    const fileName = (file as File).name;\n    const fileExt = fileName.split('.').pop();\n\n    if (fileExt === 'mcf') {\n      const mcfOut = await ParseMcf.readFile(file);\n\n      if (mcfOut['errMsgs'].length !== 0) {\n        finalReturn['errMsgs'] = finalReturn['errMsgs'].concat([{\n          'file': fileName,\n          'errs': mcfOut['errMsgs'],\n        }]);\n      }\n      \n      finalReturn['localNodes'] = mcfOut['localNodes'];\n    } else if (fileExt === 'csv') {\n      if (tmcfFile) {\n        const tmcfFileName = (tmcfFile as File).name;\n        const tmcfOut =\n        await ParseTmcf.generateMcf(tmcfFile, file).then((mcf) => {\n          const mcfParser = new ParseMcf(tmcfFileName + '&' + fileName);\n          return mcfParser.parseMcfStr(mcf as string);\n        });\n\n        if (tmcfOut['errMsgs'].length !== 0) {\n          finalReturn['errMsgs'] =\n            finalReturn['errMsgs'].concat({\n              'file': tmcfFileName,\n              'errs': tmcfOut['errMsgs'],\n            });\n        }\n        finalReturn['localNodes'] = tmcfOut['localNodes'];\n      }\n    }\n  }\n  return finalReturn;\n}\n\n/**\n  * Clears the backend data. Called when a user presses the 'Clear Files'\n  * button or uploads new files.\n  */\nfunction clearFiles() {\n  Node.nodeHash = {};\n  ParseMcf.localNodeHash = {};\n}\n\n/**\n  * Retreives a node specified by the id. If shouldCreateRemote is true, then\n  * the dcid of the retreieved node will attempt to be set. The\n  * shouldCreateRemote param is true when the user uses the search bar in the UI\n  * so that a node is always found. The node properties will display as blank\n  * and the node id will be colored red if the node does not exist in the KG.\n  *\n  * @param {String} id The id (including namespace) of the node to be retreived.\n  * @param {boolean} shouldCreateRemote Indicates is the dcid of the retreieved\n  *     node should be set to id.\n  * @return {Node} The retreived node with the given id.\n  */\nfunction retrieveNode(id: string, shouldCreateRemote: boolean) {\n  const retrieved = Node.getNode(id);\n  if (shouldCreateRemote) {\n    retrieved.setDCID(id.replace('dcid:', ''));\n  }\n  return retrieved;\n}\n\n/**\n  * Determines if passed in object is a Node object by calling the static Node\n  * class function.\n  *\n  * @param {Object} obj The object to determine if it is of Node type.\n  * @return {boolean} True if obj is of Node type and false otherwise.\n  */\nfunction isNodeObj(obj: Object) {\n  return Node.isNode(obj);\n}\n\n/**\n  * Returns the class that a node should be contained in based on how it is\n  * resolved locally and remotely.\n  *\n  * @param {Node} target The node object whose element color needs to be found.\n  * @return {String} The appropriate css class for the node.\n  */\nasync function getElemClass(target: Node) {\n  if (!target) {\n    return null;\n  }\n  if (target.existsInKG) {\n    return 'exist-in-kg';\n  }\n\n  return target.setExistsInKG().then(() => {\n    if (target.existsInKG) {\n      return 'exist-in-kg';\n    }\n\n    if (!target.dcid && target.localId &&\n        target.localId in ParseMcf.localNodeHash) {\n      return 'exist-in-local';\n    }\n\n    if (!target.dcid && !((target.localId as string) in ParseMcf.localNodeHash)) {\n      return 'not-in-local';\n    }\n    return 'not-in-kg';\n  });\n}\n\nexport {\n  readFileList,\n  clearFiles,\n  retrieveNode,\n  isNodeObj,\n  getElemClass,\n};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* Simple component to render the colors legend. */\nconst colorLegend = {\n  'exist-in-kg': 'Node has dcid that exists in DC KG',\n  'exist-in-local': 'Node has resolved local reference and no dcid',\n  'not-in-local': 'Node has unresolved local reference and no dcid',\n  'not-in-kg': 'Node has dcid which does not exist in DC KG',\n};\n\n/* Simple type to represent index of colorLegend */\nexport type ColorIndex =\n  \"exist-in-kg\" | \"exist-in-local\" | \"not-in-local\" | \"not-in-kg\";\n\n/**\n * Sets the window hash value to query a given id.\n *\n * @param {string} homeHash The hash saveed in App's state, preserving file\n *     names within url.\n * @param {string} id The id of the desired node to display. This can be either\n *     a dcid or a local id.\n */\nfunction goToId(homeHash: string, id: string) {\n  if (id.includes(':')) {\n    window.location.hash = homeHash + '&id=' + id;\n  } else {\n    window.location.hash = homeHash + '&id=dcid:' + id;\n  }\n}\n\n/**\n * Sets the window hash value to query a given id.\n * @param {string} homeHash The hash saveed in App's state, preserving file\n *     names within url.\n * @param {string} id The id of the desired node to display. This can be either\n *     a dcid or a local id.\n */\nfunction searchId(homeHash: string, id: string) {\n  if (id.includes(':')) {\n    window.location.hash = homeHash + '&search=' + id;\n  } else {\n    window.location.hash = homeHash + '&search=dcid:' + id;\n  }\n}\n\n/**\n * Sets the window hash value to given value.\n * @param {string} hash The value that the window's hash should be set to.\n */\nfunction goTo(hash: string) {\n  window.location.hash = hash;\n}\n\n/**\n * Opens the given file url.\n * @param {string} fileUrl Url of the fileee to open.\n */\nfunction openFile(fileUrl: string) {\n  if (fileUrl.startsWith('https')) {\n    window.open(fileUrl);\n  }\n}\n\n\nexport {colorLegend, goToId, goTo, openFile, searchId};\n\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, {Component} from 'react';\n\nimport {Assertion, Node} from './back-end/graph';\nimport * as API from './back-end/server-api';\nimport * as utils from './utils';\n\nconst NON_BREAKING_SPACE = '\\u00a0';\n\n\ninterface TriplesTablePropType {\n  /**\n   * List of triples to display as a table\n   */\n  triples: Assertion[];\n  /**\n   * Indicates if the given triples should be displayed as outgoing(False) or\n   * incoming(True).\n   */\n  inverse: boolean;\n  /**\n   * Set id parameter in url to the given id.\n   */\n  goToId: Function;\n}\n\ninterface TriplesTableStateType{\n  /**\n   * List of table row elements, each row representing one triple\n   */\n  tableRows: JSX.Element[] | null;\n  /**\n   * Indicates if triples are currently being fetched from the Data Commons\n   * Knowledge Graph.\n   */\n  loading: boolean;\n}\n\n/** Displays all given assertions as a table of triples. */\nexport class TriplesTable extends Component<TriplesTablePropType, TriplesTableStateType> {\n  /** Constructor for class, sets initial state\n   *\n   * @param {Object} props the props passed in by parent component\n   */\n  constructor(props: TriplesTablePropType) {\n    super(props);\n\n    this.state = {\n      tableRows: null,\n      loading: true,\n    };\n  }\n\n  /**\n  * Gets rows of triples when the array of Assertions from props is updated.\n  * @param {Object} prevProps The previous props before the component\n  *     updated, used to compare if the passed in triples have been modified.\n  */\n  componentDidUpdate(prevProps: TriplesTablePropType) {\n    if (prevProps.triples !== this.props.triples) {\n      this.setState({loading: true});\n      this.getTripleRows().then((rows) => {\n        this.setState({\n          tableRows: rows,\n          loading: false,\n        });\n      });\n    }\n  }\n  /**\n  * Returns an html element containing the styled source if the triple is\n  * inverse and the styled target otherwise.\n  * @param {Node|string} target The source of an inverse assertion or the target\n  *     of a direct assertion.\n  * @return {HtmlElement} A single cell of an html row representing a triple.\n  *     Either the source or target of the triple depending if the triple is\n  *     inverse or not.\n  */\n  async getTargetCell(target: Node | string) {\n    if (API.isNodeObj(target)) {\n      const elemClass: utils.ColorIndex = (await API.getElemClass(target as Node)) as utils.ColorIndex;\n      const nodeTarget = target as Node;\n      return (\n        <div>\n          <span title={utils.colorLegend[elemClass]}>\n            <p className ={'clickable ' + elemClass} onClick ={() =>\n              this.props.goToId(nodeTarget.localId || nodeTarget.dcid)}>\n              {nodeTarget.getRef()}\n            </p>\n          </span>\n        </div>\n      );\n    }\n    return (<p>{(target as string)}</p>);\n  }\n\n  /**\n  * Returns an html element containing the styled provenance of the triple. The\n  * provenance if of one of the following formats:\n  *     dc/<dcid>\n  *     <local mcf file>\n  *     <local tmcf file>&<local csv file>\n  *     https://<mcf file path>\n  *     https://<tmcf path>&https://<csv path>\n  *\n  * @param {string} prov The provenance of the triple.\n  * @return {HtmlElement} A single cell of an html row representing a triple.\n  *     Either the source or target of the triple depending if the triple is\n  *     inverse or not.\n  */\n  getProvenanceCell(prov: string) {\n    if (prov.startsWith('dc/')) {\n      // data commons provenance id\n      return (<p className='clickable dc-provenance'onClick={() =>\n        this.props.goToId(prov)}>{prov}</p>);\n    }\n\n    if (!prov.startsWith('https')) {\n      // local file(s) as provenance\n      return (<p>{prov.replace('&', ', ')}</p>);\n    }\n\n    if (!prov.includes('&')) {\n      // single mcf file as provenance\n      return (<p className='clickable' onClick={() =>\n        utils.openFile(prov)}>{prov.split('/').pop()}</p>);\n    }\n\n    // provenance is one tmcf and one csv\n\n    const fileNames: string[] = [];\n    const provNames = [];\n    for (const fileName of prov.split('&')) {\n      fileNames.push(fileName);\n      provNames.push(fileName.split('/').pop());\n    }\n\n    return (\n      <div>\n        <p className='clickable' onClick={() =>\n          utils.openFile(fileNames[0])}>{provNames[0]}</p>\n        <p>,{NON_BREAKING_SPACE}</p>\n        <p className='clickable' onClick={() =>\n          utils.openFile(fileNames[1])}>{provNames[1]}</p>\n      </div>\n    );\n  }\n\n  /**\n  * Converts a list of Assertion objects to an array of HTML row elements that\n  * is displyed in the TriplesTable.\n  *\n  * @return {Array<HtmlElement>} The array of HTML row elements representing\n  *     each triple.\n  */\n  async getTripleRows() {\n    const tripleRows = [];\n    let index = 0; // used to create a unique key for each row element\n\n    for (const assert of this.props.triples) {\n      const missingVal = this.props.inverse ? assert.src : assert.target;\n      const val = await this.getTargetCell(missingVal);\n\n      const prov = this.getProvenanceCell(assert.provenance);\n\n      let rowClassName;\n      if (!assert.provenance.startsWith('dc/')) {\n        // triple is not from DC KG, therefore the row should be bold\n        rowClassName = 'bold';\n      }\n\n      tripleRows.push(\n          <tr className={rowClassName} key={index}>\n            <td>{assert.property}</td>\n            <td>{val}</td>\n            <td>{prov}</td>\n          </tr>,\n      );\n      index += 1;\n    }\n    return tripleRows;\n  }\n\n  /** Renders TriplesTable component.\n   * @return {Object} component using JSX code\n   */\n  render() {\n    if (this.state.loading) {\n      // return null when loading to prevent error in rendering Promise objects\n      return null;\n    }\n    const tableHeaders = this.props.inverse ? (\n        <tr>\n          <th>Property</th>\n          <th>Source</th>\n          <th>Provenance</th>\n        </tr>\n      ) : (\n      <tr>\n        <th>Property</th>\n        <th>Target</th>\n        <th>Provenance</th>\n      </tr>\n    );\n\n    return (\n      <table>\n        <thead>\n          {tableHeaders}\n        </thead>\n        <tbody>\n          {this.state.tableRows}\n        </tbody>\n      </table>\n    );\n  }\n}\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React from 'react';\n\ninterface LoadingSpinnerPropType {\n  /**\n   * Indicates if spinner should be displayed.\n   */\n  loading: boolean;\n  /**\n   * The message to be displayed while page is loading\n   */\n  msg: string;\n}\n\n// spinning animation to demonstrate loading, used in DisplayNode and Home\nconst LoadingSpinner = (props: LoadingSpinnerPropType) => {\n  if (!props.loading) {\n    return null;\n  }\n  return (\n    <div className='centered col'>\n      <br/>\n      <div className='loadingSpinner'></div>\n      <h2>{props.msg}</h2>\n    </div>\n  );\n};\n\nexport {LoadingSpinner};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, {Component} from 'react';\n\nimport * as API from './back-end/server-api';\nimport {Node, Assertion} from './back-end/graph';\nimport {TriplesTable} from './TriplesTable';\nimport {LoadingSpinner} from './LoadingSpinner';\nimport {ColorIndex, colorLegend} from './utils';\n\ninterface DisplayNodePropType {\n  /**\n   * Node object to be displayed to user\n   */\n  node: Node;\n  /**\n   * Set id parameter in url to the given id.\n   */\n  goToId: Function;\n}\n\ninterface DisplayNodeStateType {\n  /**\n   * The reference of the node to be displayed to the user.\n   * ex: 'country/IND [l:LocalIndiaNode]'.\n   */\n  ref: string | null;\n  /**\n   * Indicates if triples are currently being fetched from the Data Commons\n   * Knowledge Graph.\n   */\n  fetching: boolean;\n  /**\n   * The triples that the current node is the subject (or source) of.\n   */\n  asserts: Assertion[];\n  /**\n   * The triples that the current node is the target of.\n   */\n  invAsserts: Assertion[];\n  /**\n   * The class of the element containing the reference of the node should be.\n   */\n  elemClass: string | null;\n}\n\n/** Displays node data for a given node passed in through props. */\nclass DisplayNode extends Component<DisplayNodePropType, DisplayNodeStateType> {\n  /** Creates DisplayNode component.\n   * @param {Object} props the props passed in by parent component\n  */\n  constructor(props: DisplayNodePropType) {\n    super(props);\n    this.state = {\n      ref: null,\n      asserts: [],\n      invAsserts: [],\n      fetching: true,\n      elemClass: null,\n    };\n  }\n\n  /** Sets node data when the component mounts. */\n  componentDidMount() {\n    this.setNodeData();\n  }\n\n  /**\n   * Sets node data when the node to display changes.\n   * @param {Object} prevProps The previous props before the component updated,\n   *     used to compare if the passed in node has changed.\n   */\n  componentDidUpdate(prevProps: DisplayNodePropType) {\n    if (prevProps.node !== this.props.node) {\n      this.setNodeData();\n    }\n  }\n\n  /**\n   * Loads data to display for the node passed in through props. This includes\n   * fetching the remote data from DC KG for the node.\n   */\n  setNodeData() {\n    const curNode = this.props.node;\n    this.setState({\n      ref: curNode.getRef(),\n      fetching: true,\n      asserts: [],\n      invAsserts: [],\n      elemClass: '',\n    });\n\n    API.getElemClass(curNode).then((elemClass) => {\n      this.setState({elemClass: elemClass});\n    });\n\n    curNode.fetchRemoteData().then(() => {\n      this.setState({\n        asserts: curNode.assertions,\n        invAsserts: curNode.invAssertions,\n        fetching: false,\n      });\n    });\n  }\n\n  /** Renders the DisplayNode component.\n   * @return {Object} the webpage using JSX code\n   * */\n  render() {\n    return (\n      <div>\n        <br/>\n        <h1 className='inline'>Currently Viewing: </h1>\n        <span title={colorLegend[this.state.elemClass as ColorIndex]}>\n          <h1 className={'inline ' + this.state.elemClass}>{this.state.ref}</h1>\n        </span>\n        <br/>\n        <LoadingSpinner loading={this.state.fetching}\n          msg='...fetching triples...'/>\n        <br/>\n        <h3 className='inline padded'>Node Properties</h3>\n        <p className='inline'> - current node is source</p>\n        <br/>\n        <TriplesTable triples={this.state.asserts} inverse={false}\n          goToId={this.props.goToId}/>\n        <br/>\n        <h3 className='inline padded'>Incoming Properties from Other Nodes</h3>\n        <p className='inline'> - current node is target</p>\n        <br/>\n        <TriplesTable triples={this.state.invAsserts} inverse={true}\n          goToId={this.props.goToId}/>\n      </div>\n    );\n  }\n}\n\nexport {DisplayNode};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, {Component} from 'react';\n\nconst ENTER_KEY = 13;\n\n\ninterface HeaderPropType {\n  /**\n   * Set a 'search' parameter in url to the specified id.\n   */\n  searchId: Function;\n  /**\n   * Return to the home page.\n   */\n  onHomeClick: React.MouseEventHandler<HTMLButtonElement>;\n  /**\n   * Ids stored in App's state for the subject nodes of triples from\n   * any parsed files.\n   */\n  subjIds: string[];\n}\n\ninterface HeaderStateType {\n  /**\n   * Text input from user via search bar.\n   */\n  searchVal: string;\n}\n\n/** Header component contains the id search bar, upload files, and return home\n  * button.\n  */\nclass Header extends Component<HeaderPropType, HeaderStateType> {\n  /** Constructor for class, sets initial state\n   *\n   * @param {Object} props the props passed in by parent component\n   */\n  constructor(props: HeaderPropType) {\n    super(props);\n    this.state = {\n      searchVal: '',\n    };\n  }\n\n  /**\n  * Calls props method to search for an id when the user presses enter.\n  * @param {Event} event OnKeyUp event from html search input element.\n  */\n  handleSearch(event: React.KeyboardEvent<HTMLInputElement>) {\n    if (event.keyCode === ENTER_KEY) {\n      this.props.searchId(event.target.value);\n      this.setState({searchVal: ''});\n    }\n  }\n\n  /** Renders header element\n   * @return {Object} the webpage using JSX code\n  */\n  render() {\n    return (\n      <div className='Header'>\n        {/* return home button*/}\n        <button className='button' onClick={this.props.onHomeClick}>\n          Return Home\n        </button>\n\n        {/* search for id w/dropdown of suggestions of the subject nodes*/}\n        <input type=\"search\" list=\"subjIds\" placeholder=\"Search by id\"\n          value={this.state.searchVal}\n          onChange={(event) => this.setState({searchVal: event.target.value})}\n          onKeyUp={(event) => {\n            this.handleSearch(event);\n          }}/>\n        <datalist id=\"subjIds\">\n          {this.props.subjIds.map((subjId) => <option value={subjId}\n            key={subjId}/>)}\n        </datalist>\n      </div>\n    );\n  }\n}\n\nexport {Header};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React from 'react';\n\nimport {ParsingError} from './back-end/utils';\n\ninterface ParsingErrorsTablePropType {\n  /**\n  * The App state's parsingErrs list of error message Objects from parsing\n  * files. Each object in the array contains one file name and one list of\n  * errors found in that file.\n  */\n errsList: ParsingError[];\n}\n\n/* Simple component to render the parsing errors table. */\nconst ParsingErrorsTable = (props: ParsingErrorsTablePropType) => {\n  if (!props.errsList.length) {\n    return null;\n  }\n  return (\n    <div className = 'box'>\n      <h3>Parsing Errors</h3>\n      <table>\n        <thead><tr>\n          <th>File Name</th>\n          <th>Line Num</th>\n          <th>Line</th>\n          <th>Error Message</th>\n        </tr></thead>\n        <tbody>\n          {props.errsList.map((errObj) => (\n            errObj['errs'].map((msg) =>\n              <tr key={msg[0]}>\n                <td>{errObj['file']}</td>\n                <td>{msg[0]}</td>\n                <td>{msg[1]}</td>\n                <td>{msg[2]}</td>\n              </tr>,\n            )))}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n\nexport {ParsingErrorsTable};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, {Component} from 'react';\n\ninterface FileEntryPropType {\n  /**\n   * Passes a file list to be submitted to the back-end for parsing.\n   */\n  upload: Function;\n  /**\n   * Passes a list of urls to be retrieved, then passed to the back-end for\n   * parsing.\n   */\n  loadFiles: Function;\n  /**\n   * Return to the home page/reset to current hash stored in App state.\n   */\n  goToHome: Function;\n  /**\n   * Sets whether the dropdown on the home page for additonal file entries\n   * should be displayed.\n   */\n  toggle: Function;\n}\n\ninterface FileEntryStateType{\n  /**\n   * Stores user's text entry in the first url entry box. This should be a url\n   * to either a MCF or TMCF file.\n   */\n  mcfTmcfUrl: string;\n  /**\n   * Stores user's text entry in the second url entry box. This should be a url\n   * to a CSV file.\n   */\n  csvUrl: string;\n}\n\ninterface FileEntryPropType {\n  /**\n   * Passes a file list to be submitted to the back-end for parsing.\n   */\n  upload: Function;\n  /**\n   * Passes a list of urls to be retrieved, then passed to the back-end for\n   * parsing.\n   */\n  loadFiles: Function;\n  /**\n   * Return to the home page/reset to current hash stored in App state.\n   */\n  goToHome: Function;\n  /**\n   * Sets whether the dropdown on the home page for additonal file entries\n   * should be displayed.\n   */\n  toggle: Function;\n}\n\ninterface FileEntryStateType{\n  /**\n   * Stores user's text entry in the first url entry box. This should be a url\n   * to either a MCF or TMCF file.\n   */\n  mcfTmcfUrl: string;\n  /**\n   * Stores user's text entry in the second url entry box. This should be a url\n   * to a CSV file.\n   */\n  csvUrl: string;\n}\n\n/** Component to display options user has for uploading files. */\nclass FileEntry extends Component<FileEntryPropType, FileEntryStateType> {\n  /** Constructor for class, sets initial state\n   * @param {Object} props the props passed in by parent component\n   */\n  constructor(props: FileEntryPropType) {\n    super(props);\n    this.state = {\n      mcfTmcfUrl: '',\n      csvUrl: '',\n    };\n  }\n\n  /**\n   * Submits the urls currently in the text input boxes to be retreived and\n   * loaded when the enter key is preessed.\n   *\n   * @param {Event} event The keyUp event that triggers the function call.\n   */\n  async handleUrlKeyUp(event: React.KeyboardEvent<HTMLInputElement>) {\n    if (event.keyCode === 13) {\n      if (this.state.mcfTmcfUrl.split('.').pop() === 'mcf') {\n        // set the base file hash with the given file names\n        await this.props.loadFiles([this.state.mcfTmcfUrl]);\n        this.setState({csvUrl: '', mcfTmcfUrl: ''});\n        // trigger hash to be set to fileHash\n        this.props.goToHome();\n        this.props.toggle();\n      } else if (this.state.mcfTmcfUrl.split('.').pop() === 'tmcf' &&\n          (this.state.csvUrl.split('.').pop() === 'csv') ) {\n        await this.props.loadFiles([this.state.mcfTmcfUrl, this.state.csvUrl]);\n        this.setState({csvUrl: '', mcfTmcfUrl: ''});\n        // trigger hash to be set to fileHash\n        this.props.goToHome();\n        this.props.toggle();\n      }\n    }\n  }\n\n  /**\n   * Renders the component by building the JSX.\n   *\n   * @return {Object} the component using JSX code\n   */\n  render() {\n    return (\n      <div className=\"row\" >\n        {/* Options to directly upload a file via file selector. */}\n        <div className=\"centered col\" >\n          <h4>Choose file(s) to upload:</h4>\n\n          {/* upload MCF file(s) */}\n          <label className='button'>\n            <input type=\"file\" required multiple\n              accept=\".mcf\" onChange={(event) => {\n                this.props.upload(Array.from(event.target.files as FileList));\n                this.props.toggle();\n              }}/>\n              Upload MCF\n          </label>\n\n          {/* upload one pair of TMCF CSV files */}\n          <label className='button'>\n            <input type=\"file\" required multiple\n              accept=\".tmcf,.csv\" onChange={(event) => {\n                this.props.upload(Array.from(event.target.files as FileList));\n                this.props.toggle();\n              }}/>\n              Upload TMCF + CSV\n          </label>\n        </div>\n\n        <div className=\"centered col\">\n          <h3>-OR-</h3>\n        </div>\n\n        {/* Options to specify url(s) to file(s). */}\n        <div className=\"centered col\" >\n          <h4>Enter URL(s):</h4>\n          <div className=\"col url-entry\" >\n\n            {/* TMCF/MCF url input */}\n            <label>MCF / TMCF:\n              <input type=\"text\"\n                value={this.state.mcfTmcfUrl}\n                onChange={(event) =>\n                  this.setState({mcfTmcfUrl: event.target.value})}\n                onKeyUp={(event) => this.handleUrlKeyUp(event)}/>\n            </label>\n\n            {/* CSV url input */}\n            <label>CSV:\n              <input type=\"text\" placeholder=\"leave blank for mcf files\"\n                value={this.state.csvUrl}\n                onChange={(event) =>\n                  this.setState({csvUrl: event.target.value})}\n                onKeyUp={(event) => this.handleUrlKeyUp(event)}/>\n            </label>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\n\nexport {FileEntry};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React, {Component} from 'react';\n\nimport {ParsingError} from './back-end/utils';\nimport {openFile} from './utils';\nimport {LoadingSpinner} from './LoadingSpinner';\nimport {ParsingErrorsTable} from './ParsingErrorsTable';\nimport {FileEntry} from './FileEntry';\n\n\ninterface HomePropType {\n  /**\n   * List of the files that have been uploaded by user.\n   */\n  fileList: Blob[];\n  /**\n   * Passes a file list to be submitted to the back-end for parsing.\n   */\n  upload: Function;\n  /**\n   * Passes a list of urls to be retrieved, then passed to the back-end for parsing.\n   */\n  loadFiles: Function;\n  /**\n   * Return to the home page.\n   */\n  goToHome: Function;\n  /**\n   * Clears the loaded data from all files and resets App to its initial state.\n   */\n  clear: React.MouseEventHandler<HTMLButtonElement>;\n  /**\n   * Error messages from parsing files specifying line number, line, and helpful\n   * message indicating the error.\n   */\n  errs: ParsingError[];\n  /**\n   * Indicates if uploaded files are currently being parsed.\n   */\n  loading: boolean;\n  /**\n   * IDs for nodes stored in App's state which are the subject nodes of triples from\n   * any parsed files.\n   */\n  subjNodes: string[];\n  /**\n   * Set id parameter in url to the given id. Used when user clicks a subject node to explore.\n   */\n  goToId: Function;\n}\n\ninterface HomeStateType{\n  /**\n   * Determines if the file entry dropdown option should be displayed.\n   */\n  dropdown: boolean;\n}\n\n/** Displays the currently loaded files, clear button, parsing errors, and\n  * subject nodes.\n  */\nclass Home extends Component<HomePropType, HomeStateType> {\n  /** Constructor for class, sets initial state\n   *\n   * @param {Object} props the props passed in by parent component\n   */\n  constructor(props: HomePropType) {\n    super(props);\n    this.state = {\n      dropdown: false,\n    };\n  }\n\n  /**\n   * Toggles the boolean value of this.state.dropdown\n   * whenever user expands or collapses the dropdown\n   */\n  toggleDropdown() {\n    this.setState({dropdown: !this.state.dropdown});\n  }\n\n  /**\n   * Renders the component\n   *\n   * @return {Object} the webpage using JSX code\n   */\n  render() {\n    if (this.props.fileList.length === 0) {\n      // show file entry options, but do not toggle dropdown on file submission\n      return (\n        <div className=\"home centered col\">\n          <div className=\"box \">\n            <FileEntry upload={this.props.upload}\n              loadFiles={this.props.loadFiles}\n              goToHome={this.props.goToHome}\n              toggle={() => {}}/>\n          </div>\n        </div>\n      );\n    }\n\n    let addFileButtonClass;\n    let addFileButtonText;\n\n    if (this.state.dropdown) {\n      addFileButtonClass = 'button expanded';\n      addFileButtonText = 'Add File (-)';\n    } else {\n      addFileButtonClass = 'button';\n      addFileButtonText = 'Add File (+)';\n    }\n\n    // show current files and subject nodes\n    return (\n      <div className=\"centered col\">\n\n        {/* list current file names*/}\n        <div className = \"box\">\n          <h3>Current Files</h3>\n          <ul>\n            {this.props.fileList.map((file, index) => {\n              const fileName = (file as File).name;\n              const className = fileName.startsWith('https:') ?\n                'clickable' : '';\n              return (\n                <li onClick={() => {\n                  if (className) openFile(fileName);\n                }}\n                className={className} key={fileName+index}>{fileName}</li>\n              );\n            })}\n          </ul>\n          <br/>\n\n          {/* display clear files button*/}\n          <button className='button' onClick={this.props.clear} >Clear</button>\n\n          <button className={addFileButtonClass} onClick={() =>\n            this.toggleDropdown()}>{addFileButtonText}</button>\n\n          {this.state.dropdown ?\n            <FileEntry\n              upload={this.props.upload}\n              loadFiles={this.props.loadFiles}\n              goToHome={this.props.goToHome}\n              toggle={() => this.toggleDropdown()}/> : null }\n\n        </div>\n        <br/>\n\n        {/* display parsing errors, if any*/}\n        <ParsingErrorsTable errsList={this.props.errs}/>\n        <br/>\n\n        <div className = \"box\">\n\n          {/* display loading animation while waiting*/}\n          <LoadingSpinner loading={this.props.loading}\n            msg='...loading mcf...'/>\n\n          {/* display list of subject noode ids*/}\n          <h3>Subject Nodes</h3>\n          <ul>\n            {this.props.subjNodes.map((dcid) =>\n              <li className='clickable' key={dcid}\n                onClick={() => this.props.goToId(dcid)}>{dcid}</li>)}\n          </ul>\n        </div>\n\n      </div>\n    );\n  }\n}\n\nexport {Home};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport './index.css';\n\nimport React, {Component} from 'react';\n\nimport axios from 'axios';\n\nimport {Node} from './back-end/graph';\nimport {DisplayNode} from './DisplayNode';\nimport {Header} from './Header';\nimport {Home} from './Home';\nimport * as utils from './utils';\nimport * as API from './back-end/server-api';\nimport {ParsingError} from './back-end/utils';\n\n/** Interface for the App component's state */\ninterface AppStateType{\n  /**\n   * Subject node IDs of the triples from files uploaded by user.\n   */\n  subjNodes: string[];\n  /**\n   * Node that should be displayed.\n   */\n  curNode: Node | null;\n  /**\n   * Files that have been uploaded by user.The locality of the csv files in\n   * relation to the tmcf files is very important! The csv will be paired with\n   * the closest tmcf file that comes before it whenever we are loading/parsing\n   * the files in the backend.\n   */\n  files: Blob[];\n  /**\n   * Indicates if any files are currently being parsed by back-end.\n   */\n  loading: boolean;\n  /**\n   * Indicates if url needs to be parsed on component mount. True when the\n   * application first loads and when files are cleared by user.\n   */\n  firstLoad: boolean;\n  /**\n   * Array of error message objects, one object per parsed file with errors. The\n   * property 'errs' is in each object is an array of String arrays, one String\n   * array per error within the given file which specifies line number, line,\n   * and helpful message indicating the error. The 'file' property provides the\n   * file name from which the error came.\n   */\n  parsingErrs: ParsingError[];\n  /**\n   * Contains the remote files specified by user in url format to be used as a\n   * home base in the hash portion of the url while using those files.\n   */\n  fileHash: string;\n\n}\n\n/** Drives the entire app and holds the state of the files and current node. */\nclass App extends Component<{}, AppStateType> {\n  initialState: Readonly<AppStateType>;\n  /** Constructor for class, sets initial state\n   *\n   * @param {Object} props the props passed in by parent component\n   */\n  constructor(props: Object) {\n    super(props);\n    this.state = {\n      subjNodes: [],\n      curNode: null,\n      files: [],\n      loading: false,\n      firstLoad: true,\n      parsingErrs: [],\n      fileHash: '#',\n    };\n    // save state for easy reset when user 'clears' files\n    this.initialState = this.state;\n  }\n\n  /**\n   * Adds an event listener to the window to respond to url hash changes. Calls\n   * the method to parse the url if the mount is the first time loading the app.\n   */\n  componentDidMount() {\n    window.addEventListener('hashchange', () => this.handleHashChange(), false);\n    if (this.state.firstLoad) {\n      this.parseUrl();\n      this.setState({firstLoad: false});\n    }\n  }\n\n  /**\n   * Sets App state according to url parameters 'id' and 'search'.\n   * The param 'id' is only set when the user clicks to the next node while\n   * navigating the triples tables or the subject nodes list.\n   * The 'search' param is set when the user uses the search bar. This causes\n   * the dcid of the retreived node to try to be set so that a node will always\n   * be displayed when a user seearches for it. If it does not exist in the KG,\n   * then the node id will appear red in the display.\n   */\n  handleHashChange() {\n    let node = null;\n\n    const params = new URLSearchParams(window.location.hash.split('#')[1]);\n    let nodeId = params.get('id');\n\n    if (nodeId) {\n      node = API.retrieveNode(nodeId, /* shouldCreateRemote */ false);\n    } else {\n      nodeId = params.get('search');\n      if (nodeId) {\n        node = API.retrieveNode(nodeId, /* shouldCreateRemote */ true);\n      }\n    }\n    this.setState({curNode: node});\n  }\n\n  /**\n   * Parses the URL upon the first load of the app. It loads the files that\n   * are specfied or navigates to a node if an id specified by the search\n   * param.\n   */\n  parseUrl() {\n    const params = new URLSearchParams(window.location.hash.trim());\n    const fileUrls = params.getAll('file');\n\n    if (fileUrls.length) {\n      this.loadRemoteFiles(fileUrls);\n    } else {\n      // get node to display from url\n      const searchId = params.get('search');\n      if (searchId) {\n        const node = API.retrieveNode(searchId, /* shouldCreateRemote */ true);\n        this.setState({curNode: node});\n      }\n    }\n  }\n\n  /**\n   * Saves the file params as part of App's state so that the files remain in\n   * the hash of the url when navigating between nodes.\n   * @param {Array<String>} fileUrlList File url list to be saved in the hash.\n   */\n  appendfileHash(fileUrlList: string[]) {\n    let hash = this.state.fileHash;\n    for (const fileUrl of fileUrlList) {\n      hash += '&file=' + fileUrl;\n    }\n    this.setState({fileHash: hash});\n  }\n\n  /**\n   * Retrieves file Blobs from array of file Urls, submits the new blobs to be\n   * parsed, and appends them to App's state list of files uploaded by user.\n   * @param {Array<string>} fileUrls The array of file urls to load and append\n   *     to App state's files object.\n   */\n  async loadRemoteFiles(fileUrls: string[]) {\n    this.appendfileHash(fileUrls);\n\n\n    const newFiles = [];\n    for (const fileUrl of fileUrls) {\n      const res = await axios.request({\n        url: fileUrl,\n        method: 'GET',\n        responseType: 'blob', // important\n      });\n\n      res.data.name = fileUrl;\n      newFiles.push(res.data);\n\n      this.setState((prevState) => ({\n        files: [...prevState.files, res.data],\n      }));\n    }\n    this.submitFileList(newFiles);\n  }\n\n  /**\n   * Saves the list of new blob files to App' state list of files and submits\n   * them to be parsed.\n   * @param {Array<Blob>} fileList File blobs selcted by user via file picker.\n   */\n  async uploadFiles(fileList: Blob[]) {\n    for (const file of fileList) {\n      await this.setState((prevState) => ({\n        files: [...prevState.files, file],\n      }));\n    }\n    this.submitFileList(this.state.files);\n  }\n\n  /**\n   * Passes list of file blobs to the 'back-end' API to be parsed and loaded\n   * into memory.\n   * @param {Array<Blob>} fileList File blobs to be parsed by back-end.\n   */\n  submitFileList(fileList: Blob[]) {\n    this.setState({loading: true});\n\n    API.readFileList(fileList).then((res) => {\n      this.setState(() => ({\n        parsingErrs: res['errMsgs'],\n        subjNodes: res['localNodes'],\n        loading: false,\n      }), () => this.handleHashChange());\n    });\n  }\n\n  /**\n   * Clear App state and calls the 'back-end' API clearFiles method.\n   */\n  onClearPress() {\n    this.setState(this.initialState);\n    API.clearFiles();\n    utils.goTo('');\n  }\n\n  /**\n   * Renders the browser by displaying a specific node or the homepage.\n   *\n   * @return {Object} the webpage using TSX code\n   */\n  render() {\n    return (\n      <div id=\"app\" >\n        <Header subjIds={this.state.subjNodes}\n          onHomeClick={() => utils.goTo(this.state.fileHash)}\n          searchId={(id: string) => utils.searchId(this.state.fileHash, id)}/>\n\n        {this.state.curNode ?\n            // if curNode is set, then display it\n            <DisplayNode node={this.state.curNode}\n              goToId={(id: string) => utils.goToId(this.state.fileHash, id)}/> :\n            // otherwise display home\n            <Home\n              fileList={this.state.files}\n              clear={() => this.onClearPress()}\n              errs={this.state.parsingErrs}\n              loading={this.state.loading}\n              subjNodes={this.state.subjNodes}\n              upload={(files: Blob[]) => this.uploadFiles(files)}\n              goToId={(id: string) => utils.goToId(this.state.fileHash, id)}\n              loadFiles={\n                (filesList: string[]) => this.loadRemoteFiles(filesList)\n              }\n              goToHome={() => utils.goTo(this.state.fileHash)}/>\n        }\n      </div>\n    );\n  }\n}\n\nexport {App};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport './index.css';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport {App} from './App';\n\nReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n"],"sourceRoot":""}